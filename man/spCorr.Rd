% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spCorr.R
\name{spCorr}
\alias{spCorr}
\title{The wrapper for the whole spCorr pipeline}
\usage{
spCorr(
  count_mat,
  gene_list,
  gene_pair_list,
  cov_mat,
  formula1 = "1",
  family1 = "nb",
  formula2 = "s(x1, x2, bs='tp', k=50)",
  family2 = quasiproductr(),
  DT = TRUE,
  global_test = "wald",
  return_models = FALSE,
  return_coefs = FALSE,
  check_morani = FALSE,
  preconstruct_smoother = TRUE,
  ncores = 2,
  control = list(),
  epsilon = 1e-06,
  seed = 123
)
}
\arguments{
\item{count_mat}{A matrix of raw gene expression counts (genes by spots/cells).}

\item{gene_list}{A vector of gene names or row indices for which marginals will be fit.}

\item{gene_pair_list}{A two-column data frame or matrix specifying gene pairs (by name or index).}

\item{cov_mat}{A data frame of covariates used in both marginal and product fitting (must contain \code{x1} and \code{x2} for spatial coordinates).}

\item{formula1}{Formula or string specifying the model structure for marginals (e.g., \code{"~ covariate"}). Use \code{"1"} for intercept-only.}

\item{family1}{Distribution family for marginal models. Options: \code{"gaussian"}, \code{"poisson"}, \code{"nb"}, or \code{"zinb"}. Default: \code{"nb"}.}

\item{formula2}{Formula or string specifying the smoother for GAMs (e.g., \code{"s(x1, x2, bs='tp', k=50)"}).}

\item{family2}{A GAM family object for product modeling (e.g., \code{quasiproductr()}).}

\item{DT}{Logical; if \code{TRUE}, applies a discrete transformation to marginals. Default is \code{TRUE}.}

\item{global_test}{Method for global testing in product models. Options: \code{"lrt"} (likelihood ratio test) or \code{"wald"} (Wald-style smooth term test). Default is \code{"wald"}.}

\item{return_models}{Logical; if \code{TRUE}, returns full GAM model objects for each gene pair. Default is \code{FALSE}.}

\item{return_coefs}{Logical; if \code{TRUE}, returns model coefficients and variances. Default is \code{FALSE}.}

\item{check_morani}{Logical; if \code{TRUE}, filters gene pairs using Moran's I on the product. Default is \code{FALSE}.}

\item{preconstruct_smoother}{Logical; if \code{TRUE}, replaces \code{bs='tp'}/\code{'gp'} with \code{tpcached}/\code{gpcached} for faster computation. Default is \code{TRUE}.}

\item{ncores}{Integer number of cores for parallel processing. Default is \code{2}.}

\item{control}{A list of control parameters passed to \code{mgcv::gam()} during product fitting.}

\item{epsilon}{A small constant to avoid boundary issues in the uniform-to-Gaussian transformation. Default is \code{1e-6}.}

\item{seed}{Random seed for reproducibility. Default is \code{123}.}
}
\value{
A named list containing:
\describe{
\item{res_global}{A vector of adjusted p-values (FDR) from global tests for each gene pair.}
\item{res_local}{A matrix of local fitted values (spatial correlation estimates) for each pair across spatial spots.}
\item{marginals}{A matrix of standardized marginal values (standard normal) for each gene.}
\item{residuals}{A matrix of uniform-transformed residuals for each gene.}
\item{model_list}{(Optional) List of fitted GAM models if \code{return_models = TRUE}.}
\item{model_coef_list}{(Optional) List of model coefficients if \code{return_coefs = TRUE}.}
}
}
\description{
This function fits conditional margins and models local correlation for a given list of genes and gene pairs using GAM-based models.
It also performs statistical testing to identify significant patterns in gene co-expression.
}
\details{
The pipeline consists of:
\enumerate{
\item Fitting conditional marginal distributions to individual genes.
\item Calculating pairwise product expressions and optionally filtering via Moran's I.
\item Fitting GAMs to model local spatial correlations between gene pairs.
\item Outputting statistical results and fitted values (or models).
}
}
\examples{
data(test_data)
result <- spCorr(
  count_mat = test_data$count_mat,
  gene_list = test_data$gene_list,
  gene_pair_list = test_data$gene_pair_list,
  cov_mat = test_data$cov_mat,
  formula1 = "layer_annotations",
  family1 = "nb",
  formula2 = "s(x1, x2, bs='tp', k=50)",
  family2 = quasiproductr(),
  DT = TRUE,
  global_test = "lrt",
  return_models = FALSE,
  return_coefs = FALSE,
  check_morani = FALSE,
  preconstruct_smoother = TRUE,
  ncores = 2,
  control = list(),
  epsilon = 1e-6,
  seed = 123
)
}
\seealso{
\code{\link[=fit_marginals]{fit_marginals()}}, \code{\link[=check_products]{check_products()}}, \code{\link[=fit_products]{fit_products()}}
}
